(self.webpackChunknew_bedford_framework=self.webpackChunknew_bedford_framework||[]).push([[7034],{37034:function(n,e,t){"use strict";t.d(e,{Z:function(){return E}});t(92338);var o=t(15671),r=t(43144),i=t(97326),a=t(60136),c=t(6215),s=t(61120),u=t(4942),v=t(37614),f=t(18596),x=t(2860),l=t(88667),d=t(3205),m=t(40780),p=t(59007),y=t(16619),g=t(457),h=t(61905),z=t(47298),_=t(66879),w=t(25079),P=t(36312),S=t.n(P),I=t(64028),C=t.n(I),M=t(42602),b=t.n(M),Z=t(64663),U=t.n(Z),D=t(82113),A=t.n(D),T={identity:S(),scale:C(),translate:b(),rotateX:U(),rotateY:A()},R=t(99998),k=t(70573),F=t(38139),N=t(63853);function j(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,o=(0,s.Z)(n);if(e){var r=(0,s.Z)(this).constructor;t=Reflect.construct(o,arguments,r)}else t=o.apply(this,arguments);return(0,c.Z)(this,t)}}var E=function(n){(0,a.Z)(t,n);var e=j(t);function t(n,r){var a;return(0,o.Z)(this,t),a=e.call(this,n,r),(0,u.Z)((0,i.Z)(a),"timer",new N.Z),(0,u.Z)((0,i.Z)(a),"scrollSpeed",0),(0,u.Z)((0,i.Z)(a),"rotationSpeed",0),(0,u.Z)((0,i.Z)(a),"distortionSpeed",0),a.isSupported?(a.createResources(),a.updateUniforms(),a.updateAutoUpdate(),a.refresh(),a):(0,c.Z)(a)}return(0,r.Z)(t,[{key:"createResources",value:function(){this.camera=new v.Z({fov:80,near:1,far:1e3}),this.camera.position=[0,0,10],(0,f.Z)(this.camera),this.modelMatrix=T.identity([]),this.drawInfo=(0,x.Z)({DrawInfoClass:l.Z,geometry:this.getGeometry({key:"conic-geometry",factory:function(){return function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.radiusTop,t=void 0===e?1:e,o=n.radiusBottom,r=void 0===o?1:o,i=n.height,a=void 0===i?1:i,c=n.radialSegments,s=void 0===c?128:c,u=n.heightSegments,v=void 0===u?1:u,f=n.thetaStart,x=void 0===f?0:f,l=n.thetaLength,d=void 0===l?2*Math.PI:l,m=n.openEnded,p=void 0===m||m,w=n.position,P=void 0===w?"aPosition":w,S=n.normal,I=void 0===S?"aNormal":S,C=n.uv,M=void 0===C?"aUv":C,b=new y.Z,Z=[],U=[],D=[],A=[],T=0,R=[],k=a/2,F=[0,0,0],N=[0,0,0],j=(r-t)/a,E=0;E<=v;E++){for(var L=[],G=E/v,q=G*(r-t)+t,X=0;X<=s;X++){var O=X/s,Y=O*d+x,B=Math.sin(Y),V=Math.cos(Y);F[0]=q*B,F[1]=-G*a+k,F[2]=q*V,Z.push.apply(Z,F),_.Z.set(N,B,j,V),_.Z.normalize(N,N),U.push.apply(U,N),D.push(O,1-G),L.push(T++)}R.push(L)}for(var H=0;H<s;H++)for(var J=0;J<v;J++){var K=R[J][H],Q=R[J+1][H],W=R[J+1][H+1],$=R[J][H+1];A.push(K,Q,$),A.push(Q,W,$)}var nn=function(n){for(var e=T,o=n?t:r,i=n?1:-1,a=1;a<=s;a++)Z.push(0,k*i,0),U.push(0,i,0),D.push(.5,.5),T++;for(var c=T,u=0;u<=s;u++){var v=u/s*d+x,f=Math.cos(v),l=Math.sin(v);Z.push(o*l,k*i,o*f),U.push(0,i,0),D.push(.5*f+.5,.5*l*i+.5),T++}for(var m=0;m<s;m++){var p=e+m,y=c+m;!0===n?A.push(y,y+1,p):A.push(y+1,y,p)}};return!1===p&&(t>0&&nn(!0),r>0&&nn(!1)),P&&(0,g.Z)(b,P,new h.Z({array:new Float32Array(Z),itemSize:3})),I&&(0,g.Z)(b,I,new h.Z({array:new Float32Array(U),itemSize:3})),M&&(0,g.Z)(b,M,new h.Z({array:new Float32Array(D),itemSize:2})),(0,z.Z)(b,new Uint16Array(A)),b}({radiusTop:1,radiusBottom:0,height:1,heightSegments:100,openEnded:!0})}}),uniforms:{uScrollTime:0,uDistortionTime:0,uRotationTime:0,uModelMatrix:this.modelMatrix,uViewMatrix:this.camera.viewMatrix,uProjectionMatrix:this.camera.projectionMatrix},program:this.getProgram({key:"conic-program",factory:function(){return new d.Z({vert:'\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2879176051(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2879176051(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2879176051(vec4 x)\n{\n  return mod289_2879176051(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2879176051(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_2879176051(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat snoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_2879176051(Pi0);\n  Pi1 = mod289_2879176051(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_2879176051(permute_2879176051(ix) + iy);\n  vec4 ixy0 = permute_2879176051(ixy + iz0);\n  vec4 ixy1 = permute_2879176051(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_2879176051(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_2879176051(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_2879176051(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aUv;\n\nuniform vec3 uCurve;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vUv;\n\nfloat easeCubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nfloat easeCubicIn(float t) {\n  return t * t * t;\n}\n\nfloat easeExpoIn(float p) {\n  return pow(2.0, 10.0 * (p - 1.0));\n}\n\nvoid main() {\n  vec3 position = aPosition;\n  float p = -(position.y - 0.5);\n\n  position.xz *= 1.0 - easeCubicOut(p) * uCurve.z;\n  position.xz += uCurve.xy * easeCubicIn(p);\n\n  vUv = aUv;\n\n  gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n}\n',frag:"\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_831717072(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_831717072(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_831717072(vec4 x) {\n     return mod289_831717072(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_831717072(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat cnoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_831717072 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_831717072 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_831717072;\n  vec3 i1 = min( g_831717072.xyz, l.zxy );\n  vec3 i2 = max( g_831717072.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_831717072.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_831717072(i);\n  vec4 p = permute_831717072( permute_831717072( permute_831717072(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_831717072.wyz - D_831717072.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_831717072 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_831717072 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_831717072.xy,h.z);\n  vec3 p3 = vec3(a1_831717072.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_831717072(vec4(dot(p0_831717072,p0_831717072), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_831717072 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_831717072,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n#define PI 3.141592653589793\n\nuniform float uScrollTime;\nuniform float uDistortionTime;\nuniform float uRotationTime;\n\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uFogColor;\nuniform float uFogIntensity;\n\nuniform float uRepeat;\nuniform float uRotation;\nuniform vec2 uGradient;\nuniform vec2 uDistortionScale;\nuniform float uDistortionAmount;\nuniform float uNoiseAmount;\nuniform float uNoiseScale;\n\nvarying vec2 vUv;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n  vec2 coord = vUv;\n  coord.x = (cos(coord.x * PI * 2.0));\n  coord.y = (cos(coord.y - uScrollTime));\n\n  float s = cnoise(vec3(coord * uDistortionScale, uDistortionTime));\n\n  coord.xy += s * uDistortionAmount;\n\n  float a = uRotation + uRotationTime;\n  vec2 angle = vec2(cos(a), sin(a));\n\n  float t = dot(vec2(0.5) - coord, angle) + 0.5;\n  t = (cos((t) * uRepeat * PI) + 1.0) * 0.5;\n\n  t += cnoise(vec3(gl_FragCoord.xy * vec2(uNoiseScale), uDistortionTime * 100.0)) * uNoiseAmount * 0.4;\n\n  float gradient = clamp(\n    map(t, uGradient.x, uGradient.y, 0.0, 1.0),\n    0.0,\n    1.0\n  );\n\n  vec3 color = mix(uColor2, uColor1, gradient);\n  color = mix(color, uFogColor, smoothstep(0.0, 1.0, (1.0 - vUv.y) * uFogIntensity));\n\n  gl_FragColor = vec4(color, 1.0);\n}\n"})}})})}},{key:"updateAutoUpdate",value:function(){var n=this.props,e=n.speed,t=n.rotationSpeed,o=n.distortionSpeed;this.autoUpdate=!(0===e&&0===t&&0===o)}},{key:"onUpdateProps",value:function(){this.updateUniforms(),this.updateAutoUpdate(),this.refresh()}},{key:"updateUniforms",value:function(){var n=this.props,e=n.curveX,t=n.curveY,o=n.curveFunnel,r=n.color1,i=n.color2,a=n.color3,c=n.fogIntensity,s=n.repeat,u=n.speed,v=n.rotation,f=n.rotationSpeed,x=n.blur,l=n.distortionScaleX,d=n.distortionScaleY,m=n.distortionIntensity,p=n.distortionSpeed,y=n.noiseIntensity,g=n.noiseScale;Object.assign(this.drawInfo.uniforms,{uCurve:[(0,F.UI)(e,-100,100,-4,4),(0,F.UI)(t,-100,100,-4,4),(0,F.UI)(o,0,100,1,0)],uColor1:(0,R.C2)(r),uColor2:(0,R.C2)(i),uFogColor:(0,R.C2)(a),uFogIntensity:(0,F.UI)(c,0,100,0,1),uRepeat:s,uRotation:(0,F.UI)(v,0,360,0,2*Math.PI),uGradient:[(0,F.UI)(x,0,100,.5,0),(0,F.UI)(x,0,100,.5,1)],uDistortionScale:[(0,F.UI)(l,0,100,0,4),(0,F.UI)(d,0,100,0,4)],uDistortionAmount:(0,F.UI)(m,0,100,0,.5),uNoiseAmount:(0,F.UI)(y,0,100,0,.5),uNoiseScale:(0,F.UI)(g,0,100,.6,.3)/this.pixelRatio}),this.scrollSpeed=(0,F.UI)(u,-100,100,-.15,.15),this.rotationSpeed=(0,F.UI)(f,-100,100,-.075,.075),this.distortionSpeed=(0,F.UI)(p,0,100,0,.075)}},{key:"update",value:function(n){var e=.001*this.timer.update(n);this.drawInfo.uniforms.uScrollTime+=e*this.scrollSpeed,this.drawInfo.uniforms.uRotationTime+=e*this.rotationSpeed,this.drawInfo.uniforms.uDistortionTime+=e*this.distortionSpeed}},{key:"render",value:function(){this.renderer.state.enable(this.renderer.gl.DEPTH_TEST),(0,m.Z)(this.renderer,this.drawInfo)}},{key:"onRefresh",value:function(){var n=this.canvas,e=n.width,t=n.height;this.camera.aspect=e/t;var o=(0,k.S)(this.camera,10),r=o.width,i=o.height,a=.5*Math.sqrt(r*r+i*i);T.identity(this.modelMatrix),T.translate(this.modelMatrix,this.modelMatrix,[0,0,-5]),T.rotateX(this.modelMatrix,this.modelMatrix,.5*Math.PI),T.scale(this.modelMatrix,this.modelMatrix,[a,10,a]),(0,p.Z)(this.camera)}}]),t}(w.Z);(0,u.Z)(E,"defaultProps",{curveX:0,curveY:0,curveFunnel:0,color1:"#d45071",color2:"#f8ba81",color3:"#ffffff",fogIntensity:0,repeat:1,speed:0,rotation:0,rotationSpeed:0,blur:0,distortionScaleX:0,distortionScaleY:0,distortionIntensity:0,distortionSpeed:0,noiseIntensity:0,noiseScale:0})},66879:function(n,e,t){"use strict";var o=t(39982),r=t.n(o),i=t(90176),a=t.n(i),c=t(69965),s=t.n(c),u=t(2738),v=t.n(u),f=t(60091),x=t.n(f);e.Z={distance:a(),copy:r(),sub:s(),set:v(),normalize:x(),setScalar:function(n,e){return n[0]=e,n[1]=e,n[2]=e,n}}},39982:function(n){n.exports=function(n,e){return n[0]=e[0],n[1]=e[1],n[2]=e[2],n}},90176:function(n){n.exports=function(n,e){var t=e[0]-n[0],o=e[1]-n[1],r=e[2]-n[2];return Math.sqrt(t*t+o*o+r*r)}},60091:function(n){n.exports=function(n,e){var t=e[0],o=e[1],r=e[2],i=t*t+o*o+r*r;i>0&&(i=1/Math.sqrt(i),n[0]=e[0]*i,n[1]=e[1]*i,n[2]=e[2]*i);return n}},2738:function(n){n.exports=function(n,e,t,o){return n[0]=e,n[1]=t,n[2]=o,n}},69965:function(n,e,t){n.exports=t(64703)},64703:function(n){n.exports=function(n,e,t){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}}}]);